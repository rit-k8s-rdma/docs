{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to rit-k8s-rdma docs \u00b6 This project aims to develop software components that allows the use of RDMA from within containers managed by Kubernetes. It differs from the previous projects it builds off of by allowing for more fine grained control over various aspects of the system, including the ability to set bandwidth limits and reserve bandwidth for specific Kubernetes pods. Introduction \u00b6 For a overview of the system, its design, and the problem it solves, see the introduction page . Components \u00b6 For a description of each of the software components that are part of the project, see the components page . Install \u00b6 For an installation guide, see the install page . Helpful Commands and Tools \u00b6 A list of useful tools and commands outside of this project is available on the helpful commands and tools page . Glossary \u00b6 For definitions of terms and acronyms, see the glossary page .","title":"Home"},{"location":"#welcome_to_rit-k8s-rdma_docs","text":"This project aims to develop software components that allows the use of RDMA from within containers managed by Kubernetes. It differs from the previous projects it builds off of by allowing for more fine grained control over various aspects of the system, including the ability to set bandwidth limits and reserve bandwidth for specific Kubernetes pods.","title":"Welcome to rit-k8s-rdma docs"},{"location":"#introduction","text":"For a overview of the system, its design, and the problem it solves, see the introduction page .","title":"Introduction"},{"location":"#components","text":"For a description of each of the software components that are part of the project, see the components page .","title":"Components"},{"location":"#install","text":"For an installation guide, see the install page .","title":"Install"},{"location":"#helpful_commands_and_tools","text":"A list of useful tools and commands outside of this project is available on the helpful commands and tools page .","title":"Helpful Commands and Tools"},{"location":"#glossary","text":"For definitions of terms and acronyms, see the glossary page .","title":"Glossary"},{"location":"components/","text":"Components \u00b6 The following are a detailed description of each of the components that make up the solution. RDMA Hardware Daemon Set \u00b6 The RDMA Harware Daemon Set is a Kubernetes Daemon Set that has two tasks. The first task is to initialize the RDMA SRIOV enabled interfaces on a node and the second task is to create a RESTful endpoint for providing metadata about the PF's and their associated VF's that exist on a given node that are part of the Kubernetes cluster. Further detail about each of the containers within the RDMA Hardware Daemon set can be seen below: Init Container - the init container is a privileged container that runs as a Kubernetes Init Container , in simplified terms this means it is run before any other container within the pod. The reason that the container needs to be run as a privileged container is because it will be working on a nodes network devices, which means it needs special access in order to configure them. The init container does two things, the first is to scan all the available interfaces on the node and determine if it is an RDMA device and whether SRIOV is enabled. For all interfaces that meet those two requirements, the init container configures each interfaces VF's to be available and ready to run. Server Container - the server container is an unprivileged container that scans through all available interfaces when starting up. It then makes a list of all interfaces that are SRIOV enabled and upon a RESTful get request from a user will return associated metadata about the container. The server container only scans the interfaces at startup because SRIOV devices can only change configurations upon a machine restart, which would rerun the init container and then the server container. The RESTful endpoint serves data in a JSON formatted list of PF's and each PF has an internal list of VF's, more info can be found here . The RESTful endpoint that the server container sets up is bound to the host network. Both the init container and the server container run under the same RDMA Hardware Daemon Set pod. When configuring how to install this pod please look at daemon set install instructions for more detail. Scheduler Extension \u00b6 The scheduler extension is a software component that is responsible for ensuring that RDMA-enabled pods are deployed onto nodes with enough RDMA resources (bandwidth and virtual functions) to support them. The scheduler extension runs alongside the kube-scheduler process within a Kubernetes cluster, and listens for HTTP requests on a TCP port (8888 by default). The extension is then registered within the configuration file for kube-scheduler (see the install page for details). Every time a new pod is being scheduled, kube-scheduler will make an HTTP request to the scheduler extenstion that contains the details of the new pod as well as a list of nodes within the cluster that kube-scheduler believe to be eligible to deploy the pod onto. The scheduler extension's job is to filter down that list based on whether the nodes in it have enough free RDMA VFs and bandwidth to support the pods requirements or not. In order to accomplish this, the scheduler extension contacts the RDMA hardware daemon set running on each of the potential nodes in the cluster to gather information about the current allocation of RDMA resources on that node. The requests to each daemon set are made in parallel, with a timeout for cases where a node's daemon set doesn't respond. Once the information has been gathered from a node, the scheduler extension calculates whether or not the node's interface and reserved bandwidth requirements can be met by the remaining resources on that node. If they can be, the node is added to a list of those that are elligible to deploy the pod onto. Once all of the nodes in the list passed in by kube-scheduler have been contacted or have timed out, this list is returned to kube-scheduler in an HTTP response. From here, kube-scheduler will limit its choice of where to place the new pod to one of the nodes in the returned list. If the returned list is empty, the pod will not be scheduled, and the output of kubectl describe for the pod will show the reasons given by the scheduler extension as to why the nodes in the list that was passed in were not eligible to host the pod. For help installing the scheduler extension and registering it with kube-scheduler, see the scheduler extension section of the install page. More information about the Kubernetes API for scheduler extensions can be found on the Kubernetes website and github . CNI Plugin \u00b6 The container network interface, or CNI, is a specification that governs the way network access is provided to containers and containerized applications. Kubernetes utilizes CNI as its standard for allocating IP addresses and network interfaces to pods that have been deployed in a cluster. A CNI plugin is a piece of software that performs that allocation, along with any other additional setup. Since RDMA network interfaces require specific additional setup to configure bandwidth limits and reservations, as well as to select virtual functions such that a pod's bandwidth requirements are satisfied, a CNI plugin is necessary for handling RDMA-enabled pods. The CNI plugin developed for this project is a fork of the existing Mellanox CNI plugin , which was limited in the fact that it always allocated one interface to each pod and didn't support bandwidth reservation or limitation. The CNI plugin for this project improves upon this by adding support for an arbitrary number of RDMA interfaces per pod, including the ability to allocate no RDMA interfaces to pods that do not need any. The CNI plugin is executed each time a pod is created or destroyed. It runs only once per pod for each of these actions, and must allocate or deallocate all of the interfaces for a pod at one time. This is done by executing an algorithm that finds a mapping of requested pod interfaces onto virtual functions that allows a pod's requirements to be satisfied. This is similar to one of the steps performed by the scheduler extension, though the scheduler extension need only determine whether a pod's requirements can be satisfied by a node, rather than what the exact final allocation of VFs to that pod will be to satisfy it. The tasks performed by the CNI plugin during pod setup are the following: Determine a placement of RDMA virtual functions that will satisfy the pod's requirements. Move each of the needed virtual functions into the pod's network namespace. Rename each of the virtual functions that have been added to the pod's network namespace. Set the bandwidth limits and reservations on each RDMA VF, if necessary. Allocate IP addresses to each of the VFs that have been allocated to the pod. The tasks performed by the CNI plugin during pod teardown are the following: Rename each of the virtual functions in the pod's network namespace. Move each of the virtual functions from the pod's network namespace back to the host's network namespace. Remove any bandwidth reservations or limitations set on the deallocated virtual functions. Dummy Device Plugin \u00b6 The Dummy Device Plugin is a stop gap measure for the current system. The directory /dev/infiniband is needed within any pod that requires RDMA. In order to access devices in this directory a container either needs to be run in privileged mode or a Device Plugin can return a directory that a container will have privileged access to. For obvious reasons we opted to create a Device Plugin for the sole purpose that it will give any container that requests an RDMA device the proper access to /dev/infiniband . This Dummy Device Plugin does not act like any other Device Plugin where it is meant to manage a specialized resources; that is done by the RDMA Hardware Daemon Set, Scheduler Extender, and CNI components. When configuring how to install this pod please look at dummy device plugin installation for more detail.","title":"Components"},{"location":"components/#components","text":"The following are a detailed description of each of the components that make up the solution.","title":"Components"},{"location":"components/#rdma_hardware_daemon_set","text":"The RDMA Harware Daemon Set is a Kubernetes Daemon Set that has two tasks. The first task is to initialize the RDMA SRIOV enabled interfaces on a node and the second task is to create a RESTful endpoint for providing metadata about the PF's and their associated VF's that exist on a given node that are part of the Kubernetes cluster. Further detail about each of the containers within the RDMA Hardware Daemon set can be seen below: Init Container - the init container is a privileged container that runs as a Kubernetes Init Container , in simplified terms this means it is run before any other container within the pod. The reason that the container needs to be run as a privileged container is because it will be working on a nodes network devices, which means it needs special access in order to configure them. The init container does two things, the first is to scan all the available interfaces on the node and determine if it is an RDMA device and whether SRIOV is enabled. For all interfaces that meet those two requirements, the init container configures each interfaces VF's to be available and ready to run. Server Container - the server container is an unprivileged container that scans through all available interfaces when starting up. It then makes a list of all interfaces that are SRIOV enabled and upon a RESTful get request from a user will return associated metadata about the container. The server container only scans the interfaces at startup because SRIOV devices can only change configurations upon a machine restart, which would rerun the init container and then the server container. The RESTful endpoint serves data in a JSON formatted list of PF's and each PF has an internal list of VF's, more info can be found here . The RESTful endpoint that the server container sets up is bound to the host network. Both the init container and the server container run under the same RDMA Hardware Daemon Set pod. When configuring how to install this pod please look at daemon set install instructions for more detail.","title":"RDMA Hardware Daemon Set"},{"location":"components/#scheduler_extension","text":"The scheduler extension is a software component that is responsible for ensuring that RDMA-enabled pods are deployed onto nodes with enough RDMA resources (bandwidth and virtual functions) to support them. The scheduler extension runs alongside the kube-scheduler process within a Kubernetes cluster, and listens for HTTP requests on a TCP port (8888 by default). The extension is then registered within the configuration file for kube-scheduler (see the install page for details). Every time a new pod is being scheduled, kube-scheduler will make an HTTP request to the scheduler extenstion that contains the details of the new pod as well as a list of nodes within the cluster that kube-scheduler believe to be eligible to deploy the pod onto. The scheduler extension's job is to filter down that list based on whether the nodes in it have enough free RDMA VFs and bandwidth to support the pods requirements or not. In order to accomplish this, the scheduler extension contacts the RDMA hardware daemon set running on each of the potential nodes in the cluster to gather information about the current allocation of RDMA resources on that node. The requests to each daemon set are made in parallel, with a timeout for cases where a node's daemon set doesn't respond. Once the information has been gathered from a node, the scheduler extension calculates whether or not the node's interface and reserved bandwidth requirements can be met by the remaining resources on that node. If they can be, the node is added to a list of those that are elligible to deploy the pod onto. Once all of the nodes in the list passed in by kube-scheduler have been contacted or have timed out, this list is returned to kube-scheduler in an HTTP response. From here, kube-scheduler will limit its choice of where to place the new pod to one of the nodes in the returned list. If the returned list is empty, the pod will not be scheduled, and the output of kubectl describe for the pod will show the reasons given by the scheduler extension as to why the nodes in the list that was passed in were not eligible to host the pod. For help installing the scheduler extension and registering it with kube-scheduler, see the scheduler extension section of the install page. More information about the Kubernetes API for scheduler extensions can be found on the Kubernetes website and github .","title":"Scheduler Extension"},{"location":"components/#cni_plugin","text":"The container network interface, or CNI, is a specification that governs the way network access is provided to containers and containerized applications. Kubernetes utilizes CNI as its standard for allocating IP addresses and network interfaces to pods that have been deployed in a cluster. A CNI plugin is a piece of software that performs that allocation, along with any other additional setup. Since RDMA network interfaces require specific additional setup to configure bandwidth limits and reservations, as well as to select virtual functions such that a pod's bandwidth requirements are satisfied, a CNI plugin is necessary for handling RDMA-enabled pods. The CNI plugin developed for this project is a fork of the existing Mellanox CNI plugin , which was limited in the fact that it always allocated one interface to each pod and didn't support bandwidth reservation or limitation. The CNI plugin for this project improves upon this by adding support for an arbitrary number of RDMA interfaces per pod, including the ability to allocate no RDMA interfaces to pods that do not need any. The CNI plugin is executed each time a pod is created or destroyed. It runs only once per pod for each of these actions, and must allocate or deallocate all of the interfaces for a pod at one time. This is done by executing an algorithm that finds a mapping of requested pod interfaces onto virtual functions that allows a pod's requirements to be satisfied. This is similar to one of the steps performed by the scheduler extension, though the scheduler extension need only determine whether a pod's requirements can be satisfied by a node, rather than what the exact final allocation of VFs to that pod will be to satisfy it. The tasks performed by the CNI plugin during pod setup are the following: Determine a placement of RDMA virtual functions that will satisfy the pod's requirements. Move each of the needed virtual functions into the pod's network namespace. Rename each of the virtual functions that have been added to the pod's network namespace. Set the bandwidth limits and reservations on each RDMA VF, if necessary. Allocate IP addresses to each of the VFs that have been allocated to the pod. The tasks performed by the CNI plugin during pod teardown are the following: Rename each of the virtual functions in the pod's network namespace. Move each of the virtual functions from the pod's network namespace back to the host's network namespace. Remove any bandwidth reservations or limitations set on the deallocated virtual functions.","title":"CNI Plugin"},{"location":"components/#dummy_device_plugin","text":"The Dummy Device Plugin is a stop gap measure for the current system. The directory /dev/infiniband is needed within any pod that requires RDMA. In order to access devices in this directory a container either needs to be run in privileged mode or a Device Plugin can return a directory that a container will have privileged access to. For obvious reasons we opted to create a Device Plugin for the sole purpose that it will give any container that requests an RDMA device the proper access to /dev/infiniband . This Dummy Device Plugin does not act like any other Device Plugin where it is meant to manage a specialized resources; that is done by the RDMA Hardware Daemon Set, Scheduler Extender, and CNI components. When configuring how to install this pod please look at dummy device plugin installation for more detail.","title":"Dummy Device Plugin"},{"location":"glossary/","text":"Glossary \u00b6 Below is a list of terminology that is good to know in order to better understand the overall application. Remote Direct Memory Access (RDMA) \u00b6 A technology that uses specialized network interface cards to access the RAM of a process running in another computer. The RDMA protocol allows data transfers to bypass the CPU and operating system kernel of both the sending and receiving computers. This enables RDMA interfaces to provide large amounts of bandwidth (40-100+ Gbps per interface), making it useful for bandwidth-intensive applications. Namespace \u00b6 An entity used to manage a processes access to a resource. Processes can only access network, filesystem, IPC, etc. resources if they are running in the same network, filesystem, IPC, etc. namespace that those resources have been placed in, respectively. Containers provide the isolation layer that underlies all containerization within Linux. See this and this for more details. Network Namespace \u00b6 Isolates network resources from processes. Every process running on a Linux system runs within some network namespace, though most are running in the \"default\" network namespace for the system. When a network interface is placed into a network namespace, only processes within that same namespace can access it. In Kubernetes, every container running within the same pod runs within the same network namespace (that is, each Kubernetes pod has its own network namespace). See here for more information. Filesystem Namespace \u00b6 Isolates filesystem resources from processes. Every process running on a Linux system runs within some network namespace. For conventional applications, this is often the \"default\" filesystem namespace with all of the systems files on it. Applications in a container typically run in their own filesystem namespace, which contains only the files packaged within that container. In Kubernetes, each container runs within its own filesystem namespace. Containers within the same pod do NOT share a filesystem namespace. Container \u00b6 Containers are simply collections of namespaces (typically one of each type) that define the environment one or more processes will run in. Which namespaces are used for the container and what resources are present within those namespaces determine what the processes running inside that container will have access to. Kubernetes \u00b6 An orchestration system for applications that exist within a container such as Docker . The orchestration system allows for managing containers across cluster of nodes. Kubelet Process \u00b6 A process that runs on each worker node within a Kubernetes cluster. Kubelet is a part of Kubernetes, and is responsible for creating new pods and container, as well as reporting resource usage information back to the Kubernetes control processes. kube-scheduler (AKA \"Kubernetes core scheduler\") \u00b6 One of the Kubernetes control processes. Responsible for determining which node in a Kubernetes cluster new pods will be run on. Scheduler extensions add functionality to kube-scheduler, and are registered within its configuration file. Pod \u00b6 The smallest unit of deployment within Kubernetes. Each pod contains one or more containers, and all the containers in a pod run on the same node in a Kubernetes cluster at the same time. Daemon Set \u00b6 A specification for a pod that is intended to be run on every worker node within a Kubernetes cluster. Deploying a Daemon Set causes every node in the cluster to run a copy of the same pod. Container Network Interface (CNI) \u00b6 A specification that describes the way network access is provided to containerized applications. This specification can be found here CNI Plugin (AKA Network Plugin) \u00b6 A Kubernetes-specific type of software component that is executed on pods as they are set up and torn down. CNI plugins perform the task of attaching a network interface to the pod they are run on. Single Root Input/Output Virtualization (SR-IOV) \u00b6 A standard for allowing physical PCI devices (referred to as PFs or \"physical functions\") to appear in software as many virtual devices (referred to as VFs or \"virtual functions\"). In this project, SR-IOV is used to split up each physical RDMA network interface into many RDMA virtual functions (allowing us to attach each virtual function to only one pod). Virtual Function (VF) \u00b6 A hardware/firmware-backed representation of a virtual PCI device. Physical Function (PF) \u00b6 An actual PCI device (an RDMA network interface in our case) that is split up into VFs.","title":"Glossary"},{"location":"glossary/#glossary","text":"Below is a list of terminology that is good to know in order to better understand the overall application.","title":"Glossary"},{"location":"glossary/#remote_direct_memory_access_rdma","text":"A technology that uses specialized network interface cards to access the RAM of a process running in another computer. The RDMA protocol allows data transfers to bypass the CPU and operating system kernel of both the sending and receiving computers. This enables RDMA interfaces to provide large amounts of bandwidth (40-100+ Gbps per interface), making it useful for bandwidth-intensive applications.","title":"Remote Direct Memory Access (RDMA)"},{"location":"glossary/#namespace","text":"An entity used to manage a processes access to a resource. Processes can only access network, filesystem, IPC, etc. resources if they are running in the same network, filesystem, IPC, etc. namespace that those resources have been placed in, respectively. Containers provide the isolation layer that underlies all containerization within Linux. See this and this for more details.","title":"Namespace"},{"location":"glossary/#network_namespace","text":"Isolates network resources from processes. Every process running on a Linux system runs within some network namespace, though most are running in the \"default\" network namespace for the system. When a network interface is placed into a network namespace, only processes within that same namespace can access it. In Kubernetes, every container running within the same pod runs within the same network namespace (that is, each Kubernetes pod has its own network namespace). See here for more information.","title":"Network Namespace"},{"location":"glossary/#filesystem_namespace","text":"Isolates filesystem resources from processes. Every process running on a Linux system runs within some network namespace. For conventional applications, this is often the \"default\" filesystem namespace with all of the systems files on it. Applications in a container typically run in their own filesystem namespace, which contains only the files packaged within that container. In Kubernetes, each container runs within its own filesystem namespace. Containers within the same pod do NOT share a filesystem namespace.","title":"Filesystem Namespace"},{"location":"glossary/#container","text":"Containers are simply collections of namespaces (typically one of each type) that define the environment one or more processes will run in. Which namespaces are used for the container and what resources are present within those namespaces determine what the processes running inside that container will have access to.","title":"Container"},{"location":"glossary/#kubernetes","text":"An orchestration system for applications that exist within a container such as Docker . The orchestration system allows for managing containers across cluster of nodes.","title":"Kubernetes"},{"location":"glossary/#kubelet_process","text":"A process that runs on each worker node within a Kubernetes cluster. Kubelet is a part of Kubernetes, and is responsible for creating new pods and container, as well as reporting resource usage information back to the Kubernetes control processes.","title":"Kubelet Process"},{"location":"glossary/#kube-scheduler_aka_kubernetes_core_scheduler","text":"One of the Kubernetes control processes. Responsible for determining which node in a Kubernetes cluster new pods will be run on. Scheduler extensions add functionality to kube-scheduler, and are registered within its configuration file.","title":"kube-scheduler (AKA \"Kubernetes core scheduler\")"},{"location":"glossary/#pod","text":"The smallest unit of deployment within Kubernetes. Each pod contains one or more containers, and all the containers in a pod run on the same node in a Kubernetes cluster at the same time.","title":"Pod"},{"location":"glossary/#daemon_set","text":"A specification for a pod that is intended to be run on every worker node within a Kubernetes cluster. Deploying a Daemon Set causes every node in the cluster to run a copy of the same pod.","title":"Daemon Set"},{"location":"glossary/#container_network_interface_cni","text":"A specification that describes the way network access is provided to containerized applications. This specification can be found here","title":"Container Network Interface (CNI)"},{"location":"glossary/#cni_plugin_aka_network_plugin","text":"A Kubernetes-specific type of software component that is executed on pods as they are set up and torn down. CNI plugins perform the task of attaching a network interface to the pod they are run on.","title":"CNI Plugin (AKA Network Plugin)"},{"location":"glossary/#single_root_inputoutput_virtualization_sr-iov","text":"A standard for allowing physical PCI devices (referred to as PFs or \"physical functions\") to appear in software as many virtual devices (referred to as VFs or \"virtual functions\"). In this project, SR-IOV is used to split up each physical RDMA network interface into many RDMA virtual functions (allowing us to attach each virtual function to only one pod).","title":"Single Root Input/Output Virtualization (SR-IOV)"},{"location":"glossary/#virtual_function_vf","text":"A hardware/firmware-backed representation of a virtual PCI device.","title":"Virtual Function (VF)"},{"location":"glossary/#physical_function_pf","text":"An actual PCI device (an RDMA network interface in our case) that is split up into VFs.","title":"Physical Function (PF)"},{"location":"helpAndTools/","text":"Helpful Commands and Tools \u00b6 Here are some helpful commands and utilities that can assist in debugging and viewing the status of a Kubernetes system outfitted with our solution. Kubernetes Commands \u00b6 Retrieve a list of all the nodes within a Kubernetes cluster (run this command on the master node of the cluster, or on a node where 'kubectl' is configured to access the Kubernetes API server process): kubectl get nodes -o wide Retrieve a list of all pods in the cluster: kubectl get pods -o wide Retieve a list of \"Kubernetes System\" pods. Pods deployed as part of the RDMA Hardware Daemon Set and Dummy Device Plugin will show up here: kubectl get pods -o wide --namespace=kube-system Delete a pod: kubectl delete pods <POD_NAME> Delete a Dameon Set: kubectl delete ds --namespace kube-system <DAEMON_SET_NAME> View the specific details of a pod: kubectl describe pods <POD_NAME> Viewing Information on RDMA Virtual Functions for a Node \u00b6 Viewing the virtual functions configured on an interface: ip link show <INTERFACE_NAME> ex: ip link show enp4s0f0 Note that the version of iproute2 (the package that provides the ip utility) on Ubuntu that we were using has a bug that causes it to crash when displaying VFs sometimes. To avoid this, use Mellanox's version of the utility, which should already be installed if you have installed Mellanox's OFED drivers for their RDMA cards: /opt/mellanox/iproute2/sbin/ip link show <INTERFACE_NAME> Executing a Shell Within a Kubernetes Container \u00b6 To do this, first access the command line on the node in the cluster that the container is running on (ie: using SSH). Next, run docker ps to determine all of the Docker containers running on that node. Search this list for the container you are interested in (the CREATED time of the container, the COMMAND run inside of it, and the container IMAGE used can all be helpful here). Each pod will have at least two containers, once 'pause' container and one or more other application containers. When executing a shell, you should do so in one of the application containers. Once you have located the correct containers, find its CONTAINER ID and execute docker exec -it <container_id> /bin/bash (note that this assumes the container has the /bin/bash executable inside of it, adjust to your environment as necessary). Errors \u00b6 A couple of misc. issues and how to address them. Kubernetes Failing to startup \u00b6 If you receive an error similair to the following when running a kubectl command: The connection to the server 129.21.34.14:6443 was refused - did you specify the right host or port? Despite kubectl being properly configured to access the Kubernetes API server, then the Kubernetes control processes are most likely not running. To verify that this is the case, you can list the Docker containers running on the master node of the cluster: docker ps If this shows no containers are running on the master node, it may be an error caused by Kubernetes failing to start due to swap space being enabled (you can look this up online for more details on why this occurs). A simple solution is to disable swapping on the master node of the cluster: sudo swapoff -a Once you have run this command, wait a minute or so and check again for Docker containers and a kubectl connection. External Documentation \u00b6 Links to other webpages and documentation that we found useful. Mellanox Documentation \u00b6 Guide to deploying Mellanox's solution for RDMA in Kubernetes containers (the solution that our project was inspired by/builds off of) link Configuring the maximum and minimum rate limits on an RDMA SR-IOV virtual function: link Configuring other attributes on a virtual function: link Sharing a single RDMA hardware interface between containers without using SR-IOV (doesn't provide the advantages of per-VF bandwidth reservation and limiting, but is useful to know about): link Mellanox RDMA driver manual for Ubuntu 16.10: link Mellanox RDMA programming manual: link Mellanox OFED manual (contains extensive information on what features Mellanox hardware/firmware has support for): link Blog post that covers what OFED is and what role it plays in the system: link Further information about Mellanox's OFED implementation and the Linux kernel modules that are a part of it: link Slides from a Mellanox presentation about RDMA: link Other \u00b6 Article on what SR-IOV is and how it works: link Information about the CNI standard: link Specifically, see the specification page itself: link External Repositories \u00b6 Links to the source code of other projects that are relevant. Mellanox Repositories \u00b6 Mellanox RDMA Device Plugin: link Mellanox CNI Plugin: link Configuration files that define the contents of Mellanox RDMA Docker container images: link RDMA Related Repositories: \u00b6 \"Hello World\" type example for RDMA programming: link Further information on the basics of writing an application that uses RDMA: link RDMA 'Verbs' specification itself: link PerfTest (RDMA toolkit that contains ib_send_bw , etc.): link","title":"Helpful Commands and Tools"},{"location":"helpAndTools/#helpful_commands_and_tools","text":"Here are some helpful commands and utilities that can assist in debugging and viewing the status of a Kubernetes system outfitted with our solution.","title":"Helpful Commands and Tools"},{"location":"helpAndTools/#kubernetes_commands","text":"Retrieve a list of all the nodes within a Kubernetes cluster (run this command on the master node of the cluster, or on a node where 'kubectl' is configured to access the Kubernetes API server process): kubectl get nodes -o wide Retrieve a list of all pods in the cluster: kubectl get pods -o wide Retieve a list of \"Kubernetes System\" pods. Pods deployed as part of the RDMA Hardware Daemon Set and Dummy Device Plugin will show up here: kubectl get pods -o wide --namespace=kube-system Delete a pod: kubectl delete pods <POD_NAME> Delete a Dameon Set: kubectl delete ds --namespace kube-system <DAEMON_SET_NAME> View the specific details of a pod: kubectl describe pods <POD_NAME>","title":"Kubernetes Commands"},{"location":"helpAndTools/#viewing_information_on_rdma_virtual_functions_for_a_node","text":"Viewing the virtual functions configured on an interface: ip link show <INTERFACE_NAME> ex: ip link show enp4s0f0 Note that the version of iproute2 (the package that provides the ip utility) on Ubuntu that we were using has a bug that causes it to crash when displaying VFs sometimes. To avoid this, use Mellanox's version of the utility, which should already be installed if you have installed Mellanox's OFED drivers for their RDMA cards: /opt/mellanox/iproute2/sbin/ip link show <INTERFACE_NAME>","title":"Viewing Information on RDMA Virtual Functions for a Node"},{"location":"helpAndTools/#executing_a_shell_within_a_kubernetes_container","text":"To do this, first access the command line on the node in the cluster that the container is running on (ie: using SSH). Next, run docker ps to determine all of the Docker containers running on that node. Search this list for the container you are interested in (the CREATED time of the container, the COMMAND run inside of it, and the container IMAGE used can all be helpful here). Each pod will have at least two containers, once 'pause' container and one or more other application containers. When executing a shell, you should do so in one of the application containers. Once you have located the correct containers, find its CONTAINER ID and execute docker exec -it <container_id> /bin/bash (note that this assumes the container has the /bin/bash executable inside of it, adjust to your environment as necessary).","title":"Executing a Shell Within a Kubernetes Container"},{"location":"helpAndTools/#errors","text":"A couple of misc. issues and how to address them.","title":"Errors"},{"location":"helpAndTools/#kubernetes_failing_to_startup","text":"If you receive an error similair to the following when running a kubectl command: The connection to the server 129.21.34.14:6443 was refused - did you specify the right host or port? Despite kubectl being properly configured to access the Kubernetes API server, then the Kubernetes control processes are most likely not running. To verify that this is the case, you can list the Docker containers running on the master node of the cluster: docker ps If this shows no containers are running on the master node, it may be an error caused by Kubernetes failing to start due to swap space being enabled (you can look this up online for more details on why this occurs). A simple solution is to disable swapping on the master node of the cluster: sudo swapoff -a Once you have run this command, wait a minute or so and check again for Docker containers and a kubectl connection.","title":"Kubernetes Failing to startup"},{"location":"helpAndTools/#external_documentation","text":"Links to other webpages and documentation that we found useful.","title":"External Documentation"},{"location":"helpAndTools/#mellanox_documentation","text":"Guide to deploying Mellanox's solution for RDMA in Kubernetes containers (the solution that our project was inspired by/builds off of) link Configuring the maximum and minimum rate limits on an RDMA SR-IOV virtual function: link Configuring other attributes on a virtual function: link Sharing a single RDMA hardware interface between containers without using SR-IOV (doesn't provide the advantages of per-VF bandwidth reservation and limiting, but is useful to know about): link Mellanox RDMA driver manual for Ubuntu 16.10: link Mellanox RDMA programming manual: link Mellanox OFED manual (contains extensive information on what features Mellanox hardware/firmware has support for): link Blog post that covers what OFED is and what role it plays in the system: link Further information about Mellanox's OFED implementation and the Linux kernel modules that are a part of it: link Slides from a Mellanox presentation about RDMA: link","title":"Mellanox Documentation"},{"location":"helpAndTools/#other","text":"Article on what SR-IOV is and how it works: link Information about the CNI standard: link Specifically, see the specification page itself: link","title":"Other"},{"location":"helpAndTools/#external_repositories","text":"Links to the source code of other projects that are relevant.","title":"External Repositories"},{"location":"helpAndTools/#mellanox_repositories","text":"Mellanox RDMA Device Plugin: link Mellanox CNI Plugin: link Configuration files that define the contents of Mellanox RDMA Docker container images: link","title":"Mellanox Repositories"},{"location":"helpAndTools/#rdma_related_repositories","text":"\"Hello World\" type example for RDMA programming: link Further information on the basics of writing an application that uses RDMA: link RDMA 'Verbs' specification itself: link PerfTest (RDMA toolkit that contains ib_send_bw , etc.): link","title":"RDMA Related Repositories:"},{"location":"install/","text":"Install \u00b6 Prerequisites \u00b6 Before installing this system, you should have a working Kubernetes cluster set up. The following prerequisites must be met: - Kubernetes version 1.13 - Golang version 1.12 - Version 1.12 or greater is necessary to compile the software components of the system. - Mellanox OFED version 4.6-1.0.1.1 or greater - The firmware on Mellanox RDMA cards should be updated to the latest available version. Hardware Setup \u00b6 This section covers the configuration of Mellanox RDMA hardware in preparation for using SR-IOV. Enable SR-IOV in the BIOS of an machine with RDMA hardware installed. Load the Mellanox driver modules for making configuration changes to the RDMA hardware. Run: sudo mst start You should expect to see output similar to the following: Starting MST (Mellanox Software Tools) driver set Loading MST PCI module - Success Loading MST PCI configuration module - Success Create devices Unloading MST PCI module (unused) - Success Determine the path to the PCI device for the RDMA hardware card. Run: sudo mst status You should expect to see output similar to the following: MST modules: ------------ MST PCI module is not loaded MST PCI configuration module loaded MST devices: ------------ /dev/mst/mt4119_pciconf0 - PCI configuration cycles access. domain:bus:dev.fn=0000:04:00.0 addr.reg=88 data.reg=92 Chip revision is: 00 The /dev/mst/ path is the path to the device: /dev/mst/mt4119_pciconf0 Query the status of the device to determine whether SR-IOV is enabled, and how many virtual functions are configured. Run: mlxconfig -d <pci_device_path> q Here, <pci_device_path> is the path to the PCI device determined in the previous step. Ex: /dev/mst/mt4119_pciconf0 You should expect to see output similar to the following: Device #1: ---------- Device type: ConnectX5 Name: MCX556A-ECA_Ax Description: ConnectX-5 VPI adapter card; EDR IB (100Gb/s) and 100GbE; dual-port QSFP28; PCIe3.0 x16; tall bracket; ROHS R6 Device: /dev/mst/mt4119_pciconf0 Configurations: Next Boot MEMIC_BAR_SIZE 0 MEMIC_SIZE_LIMIT _256KB(1) HOST_CHAINING_MODE DISABLED(0) ... NUM_OF_VFS 120 ... SRIOV_EN True(1) ... The lines of interest to us are: SRIOV_EN True(1) Which indicates whether or not SR-IOV has been enabled on the RDMA card. And: NUM_OF_VFS 120 Which indicates how many SR-IOV virtual functions have been configured on the card. We want to ensure that SR-IOV is enabled, and the number of virtual functions is configured to the largest amount the card will support. Enable SR-IOV and confuigure number of VFs. Run: mlxconfig -d <pci_device_path> set SRIOV_EN=1 NUM_OF_VFS=<max_num_vfs> Here, <pci_device_path> is the path determined in step 3, and <max_num_vfs> is the highest number of virtual functions that the RDMA hardware card supports. This can be found in the documentation for that card (this can typically be found in the firmware manual). For example: mlxconfig -d /dev/mst/mt4119_pciconf0 set SRIOV_EN=1 NUM_OF_VFS=120 Choose 'yes' when asked whether to apply the configuration. Reboot the machine. Verify that the modification worked correctly. Run: sudo mst start sudo mst status mlxconfig -d <pci_device_path> q | egrep 'NUM_OF_VFS|SRIOV_EN' Ensure that the output of the last command matches the changes you have made prior to rebooting. RDMA Hardware Daemon Set \u00b6 This section covers the installation of the RDMA Hardware Daemon Set onto all of the worker nodes in the Kubernetes cluster. Use Kubernetes to deploy the Daemon Set to all the nodes in the cluster. On the master node of the Kubernetes cluster, run: kubectl apply -f <rdma_daemonset_yaml> Where <rdma_daemonset_yaml> is a YAML file that specifies the details of the Daemon Set. This file can be found at: https://github.com/rit-k8s-rdma/rit-k8s-rdma-ds/blob/master/rdma-ds.yaml Applying this Daemon Set configuration on the Kubernetes cluster will cause each worker node to pull container images built as part of this project from our Docker Hub repository . If you would like to build this Docker image yourself, the instructions are available within the RDMA Hardware Daemon Set repository . Verify that the RDMA Hardware Daemon Set is running on each worker node in the cluster. On the master node of the Kubernetes cluster, run: kubectl get pods -o wide --namespace kube-system Within the output for this command, you should see several lines with the name: rdma-ds-* (one for each worker node in the cluster). The status column of each of these pods will show Init:0/1 while the pod is performing hardware enumeration and initialization of the SR-IOV enabled RDMA hardware. One this has completed (it may take several minutes if there are a large number of virtual functions configured on a host), the status of the pods should switch to Running . Verify that the RDMA Hardware Daemon Set's REST endpoint is running. Once the status of each hardware daemon set pod, as inspected in the previous step, is Running , the REST endpoint should be available to query. During the normal operation of the system, this would be done by the scheduler extension during the scheduling of a new pod. However, we can perform this process manually using 'curl' or a web browser. First, determine the IP address or hostname of the worker node whose RDMA Hardware Daemon Set you would like to test. Then, in a web browser, navigate to: http://<IP_OR_HOSTNAME>:54005/getpfs Where <IP_OR_HOSTNAME> is the IP or hostname of the worker node whose daemon set you would like to test, and 54005 is the port that daemon set is listening on (54005 is the default value at the time of writing). You should see output that resembles the following: [ { \"name\":\"enp4s0f0\", \"used_tx_rate\":0, \"capacity_tx_rate\":100000, \"used_vfs\":0, \"capacity_vfs\":120, \"vfs\":[ {\"vf\":0, \"mac\":\"7a:90:db:7b:30:ac\", \"vlan\":0, \"qos\":0, \"vlan_proto\": \"N/A\", \"spoof_check\":\"OFF\", \"trust\":\"ON\", \"link_state\":\"Follow\", \"min_tx_rate\":0, \"max_tx_rate\":0, \"vgt_plus\":\"OFF\", \"rate_group\":0, \"allocated\":false}, {\"vf\":1, \"mac\":\"c6:26:fe:e2:4e:95\", \"vlan\":0, \"qos\":0, \"vlan_proto\":\"N/A\", \"spoof_check\":\"OFF\", \"trust\":\"ON\", \"link_state\":\"Follow\", \"min_tx_rate\":0, \"max_tx_rate\":0, \"vgt_plus\":\"OFF\", \"rate_group\":0, \"allocated\":false}, ... ] }, { \"name\":\"enp4s0f1\", \"used_tx_rate\":0, \"capacity_tx_rate\":100000, \"used_vfs\":0, \"capacity_vfs\":120, \"vfs\":[ {\"vf\":0, \"mac\":\"02:b9:9a:99:9e:ac\", \"vlan\":0, \"qos\":0, \"vlan_proto\":\"N/A\", \"spoof_check\":\"OFF\", \"trust\":\"ON\", \"link_state\":\"Follow\", \"min_tx_rate\":0, \"max_tx_rate\":0, \"vgt_plus\":\"OFF\", \"rate_group\":0, \"allocated\":false}, {\"vf\":1, \"mac\":\"ea:99:de:00:e8:8b\", \"vlan\":0,\"qos\":0, \"vlan_proto\":\"N/A\", \"spoof_check\":\"OFF\", \"trust\":\"ON\", \"link_state\":\"Follow\", \"min_tx_rate\":0, \"max_tx_rate\":0, \"vgt_plus\":\"OFF\", \"rate_group\":0, \"allocated\":false}, ... ] }, ... ] If the RDMA Hardware Daemon Set endpoint responds, and the hardware information presented in the list it returns accurately reflects the state and details of the RDMA hardware on its node, then it is working correctly. Respeat this process for every node in the cluster to verify that each instance of the daemon set is working correctly. Scheduler Extension \u00b6 This section covers the installation of the Scheduler Extension component. Install and run the scheduler extension Docker container on the master node of the Kubernetes cluster. Run docker run -d --rm --name ritk8srdma-scheduler-entension --network host ritk8srdma/rit-k8s-rdma-scheduler-extender This will pull the Docker image for the scheduler extension from our Docker Hub repository and run it. If you would like to build the scheduler extension docker image yourself, the instructions are available within the scheduler extension repository . Modify the configuration of the core Kubernetes scheduler to register the scheduler extension. On the master node of the Kubernetes cluster, edit or add the file /etc/kubernetes/scheduler-policy-config.json to register the scheduler extension. The following entry should be added to the 'extenders' list within that file: { \"urlPrefix\": \"http://127.0.0.1:8888/scheduler\", \"filterVerb\": \"rdma_scheduling\", \"bindVerb\": \"\", \"enableHttps\": false, \"nodeCacheCapable\": false, \"ignorable\": false } Here, the IP address/port combination of 127.0.0.1 and 8888 is used because the scheduler extension is running on the same node as the core Kubernetes scheduler (the master node of the Kubernetes cluster), and listening on port 8888. If the extension is run elsewhere or listening on a different port, the 'urlPrefix' parameter should be editted accordingly. An example version of this file is available in the scheduler extension repository . Ensure the core Kubernetes scheduler is using the configuration file where the scheduler extension is registered. Edit the file /etc/kubernetes/manifests/kube-scheduler.yaml on the master node of the Kubernetes cluster. Add the following volume to the pod definition if it does not exist (place the definition within the existing 'volumes' section if one exists): volumes: - hostPath: path: /etc/kubernetes/scheduler-policy-config.json type: FileOrCreate name: scheduler-policy-config Add the following directive to the command to be run in the kube-scheduler container: --policy-config-file=/etc/kubernetes/scheduler-policy-config.json Overall, the whole file should look like: apiVersion: v1 kind: Pod metadata: annotations: scheduler.alpha.kubernetes.io/critical-pod: \"\" creationTimestamp: null labels: component: kube-scheduler tier: control-plane name: kube-scheduler namespace: kube-system spec: containers: - command: - kube-scheduler - --address=127.0.0.1 - --kubeconfig=/etc/kubernetes/scheduler.conf - --policy-config-file=/etc/kubernetes/scheduler-policy-config.json - --leader-elect=true image: k8s.gcr.io/kube-scheduler:v1.13.5 imagePullPolicy: IfNotPresent livenessProbe: failureThreshold: 8 httpGet: host: 127.0.0.1 path: /healthz port: 10251 scheme: HTTP initialDelaySeconds: 15 timeoutSeconds: 15 name: kube-scheduler resources: requests: cpu: 100m volumeMounts: - mountPath: /etc/kubernetes/scheduler.conf name: kubeconfig readOnly: true - mountPath: /etc/kubernetes/scheduler-policy-config.json name: scheduler-policy-config readOnly: true hostNetwork: true priorityClassName: system-cluster-critical volumes: - hostPath: path: /etc/kubernetes/scheduler.conf type: FileOrCreate name: kubeconfig - hostPath: path: /etc/kubernetes/scheduler-policy-config.json type: FileOrCreate name: scheduler-policy-config status: {} Ensure that the scheduler extension has started up correctly. Run docker logs ritk8srdma-scheduler-entension on the node where the scheduler extension is running. The output should include the following line at the top of its output: YYYY/MM/DD HH:MM:SS RDMA scheduler extender listening on port: <port_number> This command can be run whenever necessary to view the logging output from the scheduler extension. CNI Plugin \u00b6 This section covers the installation of the CNI plugin on each RDMA-enabled worker node in the Kubernetes cluster. Install the CNI plugin executable. Copy the 'rit-k8s-rdma-cni-linux-amd64' executable from the releases page of the repository . Place it in /opt/cni/bin/ on each RDMA-enabled worker node in the Kubernetes cluster. Install the CNI plugin configuration file. Copy the file '10-ritk8srdma-cni.conf' from the releases page of the repository . Place it in /etc/cni/net.d/ on each RDMA-enabled worker node in the Kubernetes cluster. This configuration file can be edited to fit the needs of your environment. Ensure that this file is the first one (lexicographically) within that directory. Kubernetes always uses the CNI configuration that comes first lexicographically within this directory. Within this file, the 'type' parameter specifies the name of the CNI executable that will be run when a pod is deployed. This name should match the name of the executable installed during step 1. To compile the CNI plugin binary yourself, checkout the CNI repository . Enter the 'sriov' directory within the checked-out copy of the repository, then run go install . The binary should then be created in the appropriate Golang bin directory. Dummy Device Plugin \u00b6 This section covers the installation of the Dummy Device Plugin onto all of the worker nodes in the Kubernetes cluster. Use Kubernetes to deploy the dummy device plugin to all the nodes in the cluster. On the master node of the Kubernetes cluster, run: kubectl apply -f <dummy_plugin_yaml> Where <dummy_plugin_yaml> is a YAML file that specifies the details of the Dummy Device Plugin. This file can be found at: https://github.com/rit-k8s-rdma/rit-k8s-rdma-dummy-device-plugin/blob/master/rdma-dummy-dp-ds.yaml Applying this configuration on the Kubernetes cluster will cause each worker node to pull container images built as part of this project from our Docker Hub repository . These images contain the files necessary to run the Dummy Device Plugin. If you would like to build the Dummy Device Plugin Docker image yourself, the instructions are available within the Dummy Device Plugin repository . Verify that the Dummy Device Plugin is running on each worker node in the cluster. On the master node of the Kubernetes cluster, run: kubectl get pods -o wide --namespace kube-system Within the output for this command, you should see several lines with the name: rdma-dummy-dp-ds-* (one for each worker node in the cluster). The status column of each of these pods should show Running . Pod YAML Changes \u00b6 To take advantage of RDMA within a Kubernetes pod, that pod's definition (YAML file) will need to be updated to specify the RDMA interfaces that it requires. This involves the following steps: Add the rdma_interfaces_required directive to the pod's metadata annotations: apiVersion: v1 kind: Pod metadata: name: pod1 annotations: rdma_interfaces_required: '[ {\"min_tx_rate\": 15000, \"max_tx_rate\": 20000}, {\"min_tx_rate\": 5000}, {} ]' spec: ... The value of this annotation should be a JSON-formatted string that contains a list of RDMA interfaces needed by the pod, as well as the bandwidth limitations and reservations for each of those interfaces. In this case min_tx_rate specifies an amount of bandwidth that should be reserved for the pod to use exclusively through a specific RDMA interface, while max_tx_rate sets a cap on the amount of bandwidth that can used by a pod through an interface. Either or both of these properties can be omitted if you do not need a bandwidth cap/reservation. In the example above, three RDMA interfaces are requested by a pod: the first sets both properties, the second has only a bandwidth reservation, and the third has no limit nor any reserved bandwidth. The numbers used are in units of megabits of bandwidth per second (Mb/S). Add a request for a /dev/infiniband/ mount to each container that will need access to RDMA interfaces: ... containers: - image: mellanoxubuntudocker:latest name: mofed-test-ctr1 resources: limits: rdma-sriov/dev-infiniband-mount: 1 ... The line rdma-sriov/dev-infiniband-mount: 1 indicates that the container requires privleged access to the /dev/infiniband directory. The quantity specified should be 1 (technically, the dummy device plugin is advertising an infinite amount of this resource type, but only one is needed to provide the mount point to the container). Make sure the container images being deployed in the pod contain the necessary RDMA libraries. This can be done by utilizing Mellanox's 'mellanoxubuntudocker:latest' Docker container image (and/or using this as a base to build other containers). An example of a complete pod configuration file is available from our common repository . Testing and Verification \u00b6 In order to verify that the system is working correctly, we can perform several tests. These tests will involve performing actions that exercise some components of the system, then performing checks to ensure those components functioned correctly. Deploy a Pod \u00b6 In this test, we deploy a single pod within the cluster to ensure that basic connectivity exists between the scheduler extension, dummy device plugin, and CNI plugin. Create a YAML file describing a pod to be deployed. Outfit this YAML file with the annotations mentioned in the 'Pod YAML Changes' section. Request that Kubernetes deploy the pod onto the cluster. Running this command will indicate to Kubernetes that you would like to run the pod on one of the worker nodes in the cluster. kubectl create -f <pod_yaml_filename> View the status of the pod. Running this command will inform you where in the deployment process the pod is currently. kubectl get pods -o wide Find the entry in the list that matches the name of the pod in your YAML file from step 1. You want the pod's status to be Running , though it may take several seconds to reach this state even when everything is working correctly, depending on the size of your cluster and the pod's resource requirements. If the pod does not reach the Running state after waiting for a while, you will need to perform some troubleshooting. First, observe more detailed information about the status of the pod by running: kubectl describe pod <POD_NAME> Where <POD_NAME> is the name of the pod in your YAML file from step 1. Included in the information retrieved by this command is a the annotations used to request RDMA interface(s) for the pod, as well as the state of each container within the pod. When containers have a status other than Running , they will include a reason, such as ErrImagePull , which means the Docker image used to create the container couldn't be found on the node the pod was deployed on, or on Docker Hub. Also included in the output from this command is a list of 'Events' that have occured for the pod. If this events log contains a message like: Post http://127.0.0.1:8888/scheduler/rdma_scheduling: dial tcp 127.0.0.1:8888: connect: connection refused Then the scheduler extension could not be contacted by the core Kubernetes scheduler. Make sure the scheduler is running, and is configured to listen on the port the scheduler extension is trying to reach. Alternatively, if a message like the following appears in the event log: <N> RDMA Scheduler Extension: Unable to collect information on available RDMA resources for node. Then the scheduler extension experienced a timeout or a failed connection when attempting to contact the RDMA Hardware Daemon Set instanced on <N> of the nodes in the cluster. If this occurs, repeat the verification steps from the RDMA Hardware Daemon Set installation section. If this works, then verify that the port and URL being requested from within the scheduler extension match those that the daemon set is listening on. It may be helpful to look at the scheduler extension logs in this case. Another possible message is the following: <N> RDMA Scheduler Extension: Node did not have enough free RDMA resources. Which means that the scheduler extension received information that indicated the available RDMA VFs/bandwidth on <N> of the nodes in the cluster was not enough to satisfy the pod's requirements. If this seems incorrect, repeat step 3 of the RDMA Hardware Daemon Set install section, and inspect the amount of PFs, Bandwidth, and VFs available are correct for the node (and can satisfy what the pod is requesting). Yet another message that may show up in the events log for a pod is the following: <N> RDMA Scheduler Extension: 'rdma_interfaces_required' field in pod YAML file is malformatted. This simply means that the value in the rdma_interfaces_required annotation for the pod is not a valid JSON string. Simply delete the pending pod, fix the error, and re-deploy. It may be helpful to look at the scheduler extension logs in this case as well. An error like: <N> Insufficient rdma-sriov/dev-infiniband-mount. Comes from not having the dummy device plugin installed and configured correctly. View the status of its pods with kubectl get pods -o wide --namespace kube-system , and view the log files of each instance by executing docker logs on the right container on each worker node. Finally, a few other errors specific to our system may come from the CNI plugin. These will be marked as such, but are also unexpected if the CNI plugin is installed at all. In order to view the logs for a specific instance of our CNI plugin that appears to have an issue, search the relevant node's system log for messages that begin with RIT-CNI . Test connectivity between two pods \u00b6 In order to ensure that the system has correctly provisioned pods with RDMA interfaces and set the correct bandwidth limits on those interfaces, we can run two pods on separate nodes in the Kubernetes cluster, then perform a bandwidth test between them. Create two pod YAML files with the necessary information to request at least one RDMA interface. Add node selectors for this test to ensure that the two pods are deployed to two different nodes within the cluster (naturally, the nodes chosen should have enough RDMA resources available to satisfy the rquirements of the pods, the scheduler extension will prevent the pods from being deployed otherwise). Also, ensure the container images used for these pods contain the 'ib_send_bw' RDMA testing utility, as well as the necessary RDMA libraries. Deploy the two pods onto their respective nodes in the cluster. Follow the instructions from the 'Deploy a Pod' section for troubleshooting. On the node to which the first pod has been deployed, find the Docker container running within that pod using docker ps . Execute a shell within that container by running: docker exec -ti <CONTAINER_ID> /bin/bash Where <CONTAINER_ID> is the ID of the container that you found by running docker ps . While in a shell within that container, perform the following actions: Get the pods IP address (use the IP for the eth0 interface): ifconfig Get the name of the RDMA adapter for the VF that was allocated to the pod's eth0 interface: ibdev2netdev Run the receiving (server) side of the bandwidth testing application: ib_send_bw -d <RDMA_ADAPTER_NAME> -i 1 -F --report_gbits --run_infinitely Where <RDMA_ADAPTER_NAME> is the name of the form 'mlx5_N' which was connected to the interface whose IP address you found when running ifconfig . This application is now waiting for an incoming connection. We will run the sending/client end of the test from a container within the other pod that we deployed onto another node in the cluster. On the node to which the second pod has been deployed, find a Docker container running within that pod and execute a shell within it (follow the same process as you did for the first pod). Within the shell running in the container from the second pod, perform the following actions: Get the name of the RDMA adapter for the VF that was allocated to the pod's eth0 interface: ibdev2netdev Run the sending (client) side of the bandwidth testing application: ib_send_bw -d <RDMA_ADAPTER_NAME> -i 1 -F --report_gbits <SERVER_IP> --run_infinitely Where <RDMA_ADAPTER_NAME> is the name of the form 'mlx5_N' which was connected to the eth0 interface, and <SERVER_IP> is the IP address you found for the interface within the other (first) pod in step 4. This command should display a table of bandwidth measurements that is updated periodically as it continues to run. The measurements displayed in the BW average[Gb/sec] column should all be at or below the bandwidth limit you set on the sending pod within its YAML file. If this is the case, then bandwidth limitation is working. A similar test can be run for bandwidth reservation, using additional pairs of pods that compete for bandwidth with the one that has the reservation.","title":"Install"},{"location":"install/#install","text":"","title":"Install"},{"location":"install/#prerequisites","text":"Before installing this system, you should have a working Kubernetes cluster set up. The following prerequisites must be met: - Kubernetes version 1.13 - Golang version 1.12 - Version 1.12 or greater is necessary to compile the software components of the system. - Mellanox OFED version 4.6-1.0.1.1 or greater - The firmware on Mellanox RDMA cards should be updated to the latest available version.","title":"Prerequisites"},{"location":"install/#hardware_setup","text":"This section covers the configuration of Mellanox RDMA hardware in preparation for using SR-IOV. Enable SR-IOV in the BIOS of an machine with RDMA hardware installed. Load the Mellanox driver modules for making configuration changes to the RDMA hardware. Run: sudo mst start You should expect to see output similar to the following: Starting MST (Mellanox Software Tools) driver set Loading MST PCI module - Success Loading MST PCI configuration module - Success Create devices Unloading MST PCI module (unused) - Success Determine the path to the PCI device for the RDMA hardware card. Run: sudo mst status You should expect to see output similar to the following: MST modules: ------------ MST PCI module is not loaded MST PCI configuration module loaded MST devices: ------------ /dev/mst/mt4119_pciconf0 - PCI configuration cycles access. domain:bus:dev.fn=0000:04:00.0 addr.reg=88 data.reg=92 Chip revision is: 00 The /dev/mst/ path is the path to the device: /dev/mst/mt4119_pciconf0 Query the status of the device to determine whether SR-IOV is enabled, and how many virtual functions are configured. Run: mlxconfig -d <pci_device_path> q Here, <pci_device_path> is the path to the PCI device determined in the previous step. Ex: /dev/mst/mt4119_pciconf0 You should expect to see output similar to the following: Device #1: ---------- Device type: ConnectX5 Name: MCX556A-ECA_Ax Description: ConnectX-5 VPI adapter card; EDR IB (100Gb/s) and 100GbE; dual-port QSFP28; PCIe3.0 x16; tall bracket; ROHS R6 Device: /dev/mst/mt4119_pciconf0 Configurations: Next Boot MEMIC_BAR_SIZE 0 MEMIC_SIZE_LIMIT _256KB(1) HOST_CHAINING_MODE DISABLED(0) ... NUM_OF_VFS 120 ... SRIOV_EN True(1) ... The lines of interest to us are: SRIOV_EN True(1) Which indicates whether or not SR-IOV has been enabled on the RDMA card. And: NUM_OF_VFS 120 Which indicates how many SR-IOV virtual functions have been configured on the card. We want to ensure that SR-IOV is enabled, and the number of virtual functions is configured to the largest amount the card will support. Enable SR-IOV and confuigure number of VFs. Run: mlxconfig -d <pci_device_path> set SRIOV_EN=1 NUM_OF_VFS=<max_num_vfs> Here, <pci_device_path> is the path determined in step 3, and <max_num_vfs> is the highest number of virtual functions that the RDMA hardware card supports. This can be found in the documentation for that card (this can typically be found in the firmware manual). For example: mlxconfig -d /dev/mst/mt4119_pciconf0 set SRIOV_EN=1 NUM_OF_VFS=120 Choose 'yes' when asked whether to apply the configuration. Reboot the machine. Verify that the modification worked correctly. Run: sudo mst start sudo mst status mlxconfig -d <pci_device_path> q | egrep 'NUM_OF_VFS|SRIOV_EN' Ensure that the output of the last command matches the changes you have made prior to rebooting.","title":"Hardware Setup"},{"location":"install/#rdma_hardware_daemon_set","text":"This section covers the installation of the RDMA Hardware Daemon Set onto all of the worker nodes in the Kubernetes cluster. Use Kubernetes to deploy the Daemon Set to all the nodes in the cluster. On the master node of the Kubernetes cluster, run: kubectl apply -f <rdma_daemonset_yaml> Where <rdma_daemonset_yaml> is a YAML file that specifies the details of the Daemon Set. This file can be found at: https://github.com/rit-k8s-rdma/rit-k8s-rdma-ds/blob/master/rdma-ds.yaml Applying this Daemon Set configuration on the Kubernetes cluster will cause each worker node to pull container images built as part of this project from our Docker Hub repository . If you would like to build this Docker image yourself, the instructions are available within the RDMA Hardware Daemon Set repository . Verify that the RDMA Hardware Daemon Set is running on each worker node in the cluster. On the master node of the Kubernetes cluster, run: kubectl get pods -o wide --namespace kube-system Within the output for this command, you should see several lines with the name: rdma-ds-* (one for each worker node in the cluster). The status column of each of these pods will show Init:0/1 while the pod is performing hardware enumeration and initialization of the SR-IOV enabled RDMA hardware. One this has completed (it may take several minutes if there are a large number of virtual functions configured on a host), the status of the pods should switch to Running . Verify that the RDMA Hardware Daemon Set's REST endpoint is running. Once the status of each hardware daemon set pod, as inspected in the previous step, is Running , the REST endpoint should be available to query. During the normal operation of the system, this would be done by the scheduler extension during the scheduling of a new pod. However, we can perform this process manually using 'curl' or a web browser. First, determine the IP address or hostname of the worker node whose RDMA Hardware Daemon Set you would like to test. Then, in a web browser, navigate to: http://<IP_OR_HOSTNAME>:54005/getpfs Where <IP_OR_HOSTNAME> is the IP or hostname of the worker node whose daemon set you would like to test, and 54005 is the port that daemon set is listening on (54005 is the default value at the time of writing). You should see output that resembles the following: [ { \"name\":\"enp4s0f0\", \"used_tx_rate\":0, \"capacity_tx_rate\":100000, \"used_vfs\":0, \"capacity_vfs\":120, \"vfs\":[ {\"vf\":0, \"mac\":\"7a:90:db:7b:30:ac\", \"vlan\":0, \"qos\":0, \"vlan_proto\": \"N/A\", \"spoof_check\":\"OFF\", \"trust\":\"ON\", \"link_state\":\"Follow\", \"min_tx_rate\":0, \"max_tx_rate\":0, \"vgt_plus\":\"OFF\", \"rate_group\":0, \"allocated\":false}, {\"vf\":1, \"mac\":\"c6:26:fe:e2:4e:95\", \"vlan\":0, \"qos\":0, \"vlan_proto\":\"N/A\", \"spoof_check\":\"OFF\", \"trust\":\"ON\", \"link_state\":\"Follow\", \"min_tx_rate\":0, \"max_tx_rate\":0, \"vgt_plus\":\"OFF\", \"rate_group\":0, \"allocated\":false}, ... ] }, { \"name\":\"enp4s0f1\", \"used_tx_rate\":0, \"capacity_tx_rate\":100000, \"used_vfs\":0, \"capacity_vfs\":120, \"vfs\":[ {\"vf\":0, \"mac\":\"02:b9:9a:99:9e:ac\", \"vlan\":0, \"qos\":0, \"vlan_proto\":\"N/A\", \"spoof_check\":\"OFF\", \"trust\":\"ON\", \"link_state\":\"Follow\", \"min_tx_rate\":0, \"max_tx_rate\":0, \"vgt_plus\":\"OFF\", \"rate_group\":0, \"allocated\":false}, {\"vf\":1, \"mac\":\"ea:99:de:00:e8:8b\", \"vlan\":0,\"qos\":0, \"vlan_proto\":\"N/A\", \"spoof_check\":\"OFF\", \"trust\":\"ON\", \"link_state\":\"Follow\", \"min_tx_rate\":0, \"max_tx_rate\":0, \"vgt_plus\":\"OFF\", \"rate_group\":0, \"allocated\":false}, ... ] }, ... ] If the RDMA Hardware Daemon Set endpoint responds, and the hardware information presented in the list it returns accurately reflects the state and details of the RDMA hardware on its node, then it is working correctly. Respeat this process for every node in the cluster to verify that each instance of the daemon set is working correctly.","title":"RDMA Hardware Daemon Set"},{"location":"install/#scheduler_extension","text":"This section covers the installation of the Scheduler Extension component. Install and run the scheduler extension Docker container on the master node of the Kubernetes cluster. Run docker run -d --rm --name ritk8srdma-scheduler-entension --network host ritk8srdma/rit-k8s-rdma-scheduler-extender This will pull the Docker image for the scheduler extension from our Docker Hub repository and run it. If you would like to build the scheduler extension docker image yourself, the instructions are available within the scheduler extension repository . Modify the configuration of the core Kubernetes scheduler to register the scheduler extension. On the master node of the Kubernetes cluster, edit or add the file /etc/kubernetes/scheduler-policy-config.json to register the scheduler extension. The following entry should be added to the 'extenders' list within that file: { \"urlPrefix\": \"http://127.0.0.1:8888/scheduler\", \"filterVerb\": \"rdma_scheduling\", \"bindVerb\": \"\", \"enableHttps\": false, \"nodeCacheCapable\": false, \"ignorable\": false } Here, the IP address/port combination of 127.0.0.1 and 8888 is used because the scheduler extension is running on the same node as the core Kubernetes scheduler (the master node of the Kubernetes cluster), and listening on port 8888. If the extension is run elsewhere or listening on a different port, the 'urlPrefix' parameter should be editted accordingly. An example version of this file is available in the scheduler extension repository . Ensure the core Kubernetes scheduler is using the configuration file where the scheduler extension is registered. Edit the file /etc/kubernetes/manifests/kube-scheduler.yaml on the master node of the Kubernetes cluster. Add the following volume to the pod definition if it does not exist (place the definition within the existing 'volumes' section if one exists): volumes: - hostPath: path: /etc/kubernetes/scheduler-policy-config.json type: FileOrCreate name: scheduler-policy-config Add the following directive to the command to be run in the kube-scheduler container: --policy-config-file=/etc/kubernetes/scheduler-policy-config.json Overall, the whole file should look like: apiVersion: v1 kind: Pod metadata: annotations: scheduler.alpha.kubernetes.io/critical-pod: \"\" creationTimestamp: null labels: component: kube-scheduler tier: control-plane name: kube-scheduler namespace: kube-system spec: containers: - command: - kube-scheduler - --address=127.0.0.1 - --kubeconfig=/etc/kubernetes/scheduler.conf - --policy-config-file=/etc/kubernetes/scheduler-policy-config.json - --leader-elect=true image: k8s.gcr.io/kube-scheduler:v1.13.5 imagePullPolicy: IfNotPresent livenessProbe: failureThreshold: 8 httpGet: host: 127.0.0.1 path: /healthz port: 10251 scheme: HTTP initialDelaySeconds: 15 timeoutSeconds: 15 name: kube-scheduler resources: requests: cpu: 100m volumeMounts: - mountPath: /etc/kubernetes/scheduler.conf name: kubeconfig readOnly: true - mountPath: /etc/kubernetes/scheduler-policy-config.json name: scheduler-policy-config readOnly: true hostNetwork: true priorityClassName: system-cluster-critical volumes: - hostPath: path: /etc/kubernetes/scheduler.conf type: FileOrCreate name: kubeconfig - hostPath: path: /etc/kubernetes/scheduler-policy-config.json type: FileOrCreate name: scheduler-policy-config status: {} Ensure that the scheduler extension has started up correctly. Run docker logs ritk8srdma-scheduler-entension on the node where the scheduler extension is running. The output should include the following line at the top of its output: YYYY/MM/DD HH:MM:SS RDMA scheduler extender listening on port: <port_number> This command can be run whenever necessary to view the logging output from the scheduler extension.","title":"Scheduler Extension"},{"location":"install/#cni_plugin","text":"This section covers the installation of the CNI plugin on each RDMA-enabled worker node in the Kubernetes cluster. Install the CNI plugin executable. Copy the 'rit-k8s-rdma-cni-linux-amd64' executable from the releases page of the repository . Place it in /opt/cni/bin/ on each RDMA-enabled worker node in the Kubernetes cluster. Install the CNI plugin configuration file. Copy the file '10-ritk8srdma-cni.conf' from the releases page of the repository . Place it in /etc/cni/net.d/ on each RDMA-enabled worker node in the Kubernetes cluster. This configuration file can be edited to fit the needs of your environment. Ensure that this file is the first one (lexicographically) within that directory. Kubernetes always uses the CNI configuration that comes first lexicographically within this directory. Within this file, the 'type' parameter specifies the name of the CNI executable that will be run when a pod is deployed. This name should match the name of the executable installed during step 1. To compile the CNI plugin binary yourself, checkout the CNI repository . Enter the 'sriov' directory within the checked-out copy of the repository, then run go install . The binary should then be created in the appropriate Golang bin directory.","title":"CNI Plugin"},{"location":"install/#dummy_device_plugin","text":"This section covers the installation of the Dummy Device Plugin onto all of the worker nodes in the Kubernetes cluster. Use Kubernetes to deploy the dummy device plugin to all the nodes in the cluster. On the master node of the Kubernetes cluster, run: kubectl apply -f <dummy_plugin_yaml> Where <dummy_plugin_yaml> is a YAML file that specifies the details of the Dummy Device Plugin. This file can be found at: https://github.com/rit-k8s-rdma/rit-k8s-rdma-dummy-device-plugin/blob/master/rdma-dummy-dp-ds.yaml Applying this configuration on the Kubernetes cluster will cause each worker node to pull container images built as part of this project from our Docker Hub repository . These images contain the files necessary to run the Dummy Device Plugin. If you would like to build the Dummy Device Plugin Docker image yourself, the instructions are available within the Dummy Device Plugin repository . Verify that the Dummy Device Plugin is running on each worker node in the cluster. On the master node of the Kubernetes cluster, run: kubectl get pods -o wide --namespace kube-system Within the output for this command, you should see several lines with the name: rdma-dummy-dp-ds-* (one for each worker node in the cluster). The status column of each of these pods should show Running .","title":"Dummy Device Plugin"},{"location":"install/#pod_yaml_changes","text":"To take advantage of RDMA within a Kubernetes pod, that pod's definition (YAML file) will need to be updated to specify the RDMA interfaces that it requires. This involves the following steps: Add the rdma_interfaces_required directive to the pod's metadata annotations: apiVersion: v1 kind: Pod metadata: name: pod1 annotations: rdma_interfaces_required: '[ {\"min_tx_rate\": 15000, \"max_tx_rate\": 20000}, {\"min_tx_rate\": 5000}, {} ]' spec: ... The value of this annotation should be a JSON-formatted string that contains a list of RDMA interfaces needed by the pod, as well as the bandwidth limitations and reservations for each of those interfaces. In this case min_tx_rate specifies an amount of bandwidth that should be reserved for the pod to use exclusively through a specific RDMA interface, while max_tx_rate sets a cap on the amount of bandwidth that can used by a pod through an interface. Either or both of these properties can be omitted if you do not need a bandwidth cap/reservation. In the example above, three RDMA interfaces are requested by a pod: the first sets both properties, the second has only a bandwidth reservation, and the third has no limit nor any reserved bandwidth. The numbers used are in units of megabits of bandwidth per second (Mb/S). Add a request for a /dev/infiniband/ mount to each container that will need access to RDMA interfaces: ... containers: - image: mellanoxubuntudocker:latest name: mofed-test-ctr1 resources: limits: rdma-sriov/dev-infiniband-mount: 1 ... The line rdma-sriov/dev-infiniband-mount: 1 indicates that the container requires privleged access to the /dev/infiniband directory. The quantity specified should be 1 (technically, the dummy device plugin is advertising an infinite amount of this resource type, but only one is needed to provide the mount point to the container). Make sure the container images being deployed in the pod contain the necessary RDMA libraries. This can be done by utilizing Mellanox's 'mellanoxubuntudocker:latest' Docker container image (and/or using this as a base to build other containers). An example of a complete pod configuration file is available from our common repository .","title":"Pod YAML Changes"},{"location":"install/#testing_and_verification","text":"In order to verify that the system is working correctly, we can perform several tests. These tests will involve performing actions that exercise some components of the system, then performing checks to ensure those components functioned correctly.","title":"Testing and Verification"},{"location":"install/#deploy_a_pod","text":"In this test, we deploy a single pod within the cluster to ensure that basic connectivity exists between the scheduler extension, dummy device plugin, and CNI plugin. Create a YAML file describing a pod to be deployed. Outfit this YAML file with the annotations mentioned in the 'Pod YAML Changes' section. Request that Kubernetes deploy the pod onto the cluster. Running this command will indicate to Kubernetes that you would like to run the pod on one of the worker nodes in the cluster. kubectl create -f <pod_yaml_filename> View the status of the pod. Running this command will inform you where in the deployment process the pod is currently. kubectl get pods -o wide Find the entry in the list that matches the name of the pod in your YAML file from step 1. You want the pod's status to be Running , though it may take several seconds to reach this state even when everything is working correctly, depending on the size of your cluster and the pod's resource requirements. If the pod does not reach the Running state after waiting for a while, you will need to perform some troubleshooting. First, observe more detailed information about the status of the pod by running: kubectl describe pod <POD_NAME> Where <POD_NAME> is the name of the pod in your YAML file from step 1. Included in the information retrieved by this command is a the annotations used to request RDMA interface(s) for the pod, as well as the state of each container within the pod. When containers have a status other than Running , they will include a reason, such as ErrImagePull , which means the Docker image used to create the container couldn't be found on the node the pod was deployed on, or on Docker Hub. Also included in the output from this command is a list of 'Events' that have occured for the pod. If this events log contains a message like: Post http://127.0.0.1:8888/scheduler/rdma_scheduling: dial tcp 127.0.0.1:8888: connect: connection refused Then the scheduler extension could not be contacted by the core Kubernetes scheduler. Make sure the scheduler is running, and is configured to listen on the port the scheduler extension is trying to reach. Alternatively, if a message like the following appears in the event log: <N> RDMA Scheduler Extension: Unable to collect information on available RDMA resources for node. Then the scheduler extension experienced a timeout or a failed connection when attempting to contact the RDMA Hardware Daemon Set instanced on <N> of the nodes in the cluster. If this occurs, repeat the verification steps from the RDMA Hardware Daemon Set installation section. If this works, then verify that the port and URL being requested from within the scheduler extension match those that the daemon set is listening on. It may be helpful to look at the scheduler extension logs in this case. Another possible message is the following: <N> RDMA Scheduler Extension: Node did not have enough free RDMA resources. Which means that the scheduler extension received information that indicated the available RDMA VFs/bandwidth on <N> of the nodes in the cluster was not enough to satisfy the pod's requirements. If this seems incorrect, repeat step 3 of the RDMA Hardware Daemon Set install section, and inspect the amount of PFs, Bandwidth, and VFs available are correct for the node (and can satisfy what the pod is requesting). Yet another message that may show up in the events log for a pod is the following: <N> RDMA Scheduler Extension: 'rdma_interfaces_required' field in pod YAML file is malformatted. This simply means that the value in the rdma_interfaces_required annotation for the pod is not a valid JSON string. Simply delete the pending pod, fix the error, and re-deploy. It may be helpful to look at the scheduler extension logs in this case as well. An error like: <N> Insufficient rdma-sriov/dev-infiniband-mount. Comes from not having the dummy device plugin installed and configured correctly. View the status of its pods with kubectl get pods -o wide --namespace kube-system , and view the log files of each instance by executing docker logs on the right container on each worker node. Finally, a few other errors specific to our system may come from the CNI plugin. These will be marked as such, but are also unexpected if the CNI plugin is installed at all. In order to view the logs for a specific instance of our CNI plugin that appears to have an issue, search the relevant node's system log for messages that begin with RIT-CNI .","title":"Deploy a Pod"},{"location":"install/#test_connectivity_between_two_pods","text":"In order to ensure that the system has correctly provisioned pods with RDMA interfaces and set the correct bandwidth limits on those interfaces, we can run two pods on separate nodes in the Kubernetes cluster, then perform a bandwidth test between them. Create two pod YAML files with the necessary information to request at least one RDMA interface. Add node selectors for this test to ensure that the two pods are deployed to two different nodes within the cluster (naturally, the nodes chosen should have enough RDMA resources available to satisfy the rquirements of the pods, the scheduler extension will prevent the pods from being deployed otherwise). Also, ensure the container images used for these pods contain the 'ib_send_bw' RDMA testing utility, as well as the necessary RDMA libraries. Deploy the two pods onto their respective nodes in the cluster. Follow the instructions from the 'Deploy a Pod' section for troubleshooting. On the node to which the first pod has been deployed, find the Docker container running within that pod using docker ps . Execute a shell within that container by running: docker exec -ti <CONTAINER_ID> /bin/bash Where <CONTAINER_ID> is the ID of the container that you found by running docker ps . While in a shell within that container, perform the following actions: Get the pods IP address (use the IP for the eth0 interface): ifconfig Get the name of the RDMA adapter for the VF that was allocated to the pod's eth0 interface: ibdev2netdev Run the receiving (server) side of the bandwidth testing application: ib_send_bw -d <RDMA_ADAPTER_NAME> -i 1 -F --report_gbits --run_infinitely Where <RDMA_ADAPTER_NAME> is the name of the form 'mlx5_N' which was connected to the interface whose IP address you found when running ifconfig . This application is now waiting for an incoming connection. We will run the sending/client end of the test from a container within the other pod that we deployed onto another node in the cluster. On the node to which the second pod has been deployed, find a Docker container running within that pod and execute a shell within it (follow the same process as you did for the first pod). Within the shell running in the container from the second pod, perform the following actions: Get the name of the RDMA adapter for the VF that was allocated to the pod's eth0 interface: ibdev2netdev Run the sending (client) side of the bandwidth testing application: ib_send_bw -d <RDMA_ADAPTER_NAME> -i 1 -F --report_gbits <SERVER_IP> --run_infinitely Where <RDMA_ADAPTER_NAME> is the name of the form 'mlx5_N' which was connected to the eth0 interface, and <SERVER_IP> is the IP address you found for the interface within the other (first) pod in step 4. This command should display a table of bandwidth measurements that is updated periodically as it continues to run. The measurements displayed in the BW average[Gb/sec] column should all be at or below the bandwidth limit you set on the sending pod within its YAML file. If this is the case, then bandwidth limitation is working. A similar test can be run for bandwidth reservation, using additional pairs of pods that compete for bandwidth with the one that has the reservation.","title":"Test connectivity between two pods"},{"location":"introduction/","text":"Introduction \u00b6 The main focus of this project was to enable bandwidth limiting and allow for multiple interfaces to be specified for RDMA interfaces on a per pod basis. The current Mellanox Solution has a number of pitfalls such as an inaccurate state between the CNI and the Device Plugin. The Device Plugin is managed by Kubernetes, so Kubernets decides which interface to allocate to a given container. This is not reflected accurately in the CNI which may give it a different interface. In the current solution a pod may have 3 containers that each request a single RDMA interface; in the solution the Device Plugin removes 3 RDMA interfaces from the available pool of interfaces, but the CNI only allocates a single interface; the state of the CNI and the Device Plugin are incorrect. One of the largest problems is that Mellanox treats RDMA interfaces as a container specified resource, when in reality network namespaces are shared across pods, so any container in a pod has access to all of the same interfaces. This becomes a problem because when specifying Device Resources within a pod yaml, they are on a per container basis. For all of the reasons above the Device Plugin approach was abandoned because it could not accommodate our goals and instead we opted for a new architecture. Architecture \u00b6 The main system architecture for our design can be seen below; the green color specifies our components for our design and the yellow color specify Kubernetes components: The main workflow for how a pod would deployed in our system begins with a request for deploying a pod going to the master nodes Kubernetes Control Process. After that request is seen the Kubernetes Scheduler creates a list of possible nodes that the pod can be placed on based on requirements of the pods yaml. This list then gets sent to our Scheduler Extension , which is in charge of deciding which nodes can support the RDMA requirements specified in the pods yaml. The Scheduler Extension contacts each nodes RDMA Hardware Daemon Set , which returns a JSON formatted list of information about a nodes RDMA VF's back to the Scheduler Extension . The Scheduler Extension than processes all of the information to find a valid node that can meet the minimum bandwidth requirements of each of the requested interfaces that is specified in the pods yaml; the list of nodes whether blank or empty is sent back to the Kubernetes Core Scheduler. If no node is valid after the scheduling calls an error is raised and the pod is not placed, this error can be seen with a Kubernetes describe command of why the pod was not placed. Assuming that the pod was able to placed on at least one valid node, the Kubelet process on the valid node gets called to setup the pod. During the pods setup process the (CNI)[components.md#cni] is called to setup the network of the pod. The (CNI)[components.md#cni] first contacts the RDMA Hardware Daemon Set on the node that is running to get an up to date list of the state of the node. It then runs the same algorithm that the Scheduler Extension had run to find the correct placements of interfaces to meet the requirements of the bandwidth limitations. The (CNI)[components.md#cni] is atomic operation, so it either completes the setup of the pod or fails and rollbacks all changes made to any interfaces. Once the (CNI)[components.md#cni] finishes, the response is sent back to the Kubelet process of the node. Limitations \u00b6 There are a couple limitations when it comes to our solution: - Mellanox Vendor - the following has only been test on a Mellanox Card - Data Plane Development Kit (DPDK) - the Mellanox solution may work with DPDK, it has not been tested with our solution (changes to (CNI)[https://github.com/rit-k8s-rdma/rit-k8s-rdma-sriov-cni] required) - Shared RDMA Device - the Mellanox solution may work with a shared RDMA interface, it has not been tested with our solution (changes to (CNI)[https://github.com/rit-k8s-rdma/rit-k8s-rdma-sriov-cni] required) - Dummy Device Plugin - the current solution requires the use of Device Plugin to give access to /dev/infiniband for open issues in Kubernets that can be found here and here . The main problem is Kubernetes does not have the ideas of a device directory that Docker has --device . Future Work \u00b6 More Vendors - making the solution more interface driven so it can be adapted to more vendors then just Mellanox. Migrating CNI - the CNI is currently at an older version and we had to bootstrap the newer one, it should be upgraded. Scheduling - opening up the scheduler to be more adaptable to customizable scheduling algorithms. Our Approach in Short \u00b6 Problems Addressed: - VF's are specified per container - Network plugin only ever gives one vf per pod, this means that the device plugin which tracks the amount of available VF's does not maintain an accurate count of VF's being used - The VF's selected by Kuberentes to be allocated, may not match those actually allocated by the network plugin Solution: - Device Plugin (RDMA) - Changes to a DameonSet - Stores the current state of the nodes VF resources - Can be quierried through an API - Schedular extender - Queries each DameonSet on each node and then filters the possible nodes that a pod can be deployed on based on resource requirements in the annotations for the pod - Network Plugin (SRIOV) - Modify it to handle read pods meta-data - Read the amount of VF's - Read the bandwidth limitation on each VF - Modify plugin to set the bandwidth limits from read metadata - Add ability to set min_tx_rate and max_tx_rate","title":"Introduction"},{"location":"introduction/#introduction","text":"The main focus of this project was to enable bandwidth limiting and allow for multiple interfaces to be specified for RDMA interfaces on a per pod basis. The current Mellanox Solution has a number of pitfalls such as an inaccurate state between the CNI and the Device Plugin. The Device Plugin is managed by Kubernetes, so Kubernets decides which interface to allocate to a given container. This is not reflected accurately in the CNI which may give it a different interface. In the current solution a pod may have 3 containers that each request a single RDMA interface; in the solution the Device Plugin removes 3 RDMA interfaces from the available pool of interfaces, but the CNI only allocates a single interface; the state of the CNI and the Device Plugin are incorrect. One of the largest problems is that Mellanox treats RDMA interfaces as a container specified resource, when in reality network namespaces are shared across pods, so any container in a pod has access to all of the same interfaces. This becomes a problem because when specifying Device Resources within a pod yaml, they are on a per container basis. For all of the reasons above the Device Plugin approach was abandoned because it could not accommodate our goals and instead we opted for a new architecture.","title":"Introduction"},{"location":"introduction/#architecture","text":"The main system architecture for our design can be seen below; the green color specifies our components for our design and the yellow color specify Kubernetes components: The main workflow for how a pod would deployed in our system begins with a request for deploying a pod going to the master nodes Kubernetes Control Process. After that request is seen the Kubernetes Scheduler creates a list of possible nodes that the pod can be placed on based on requirements of the pods yaml. This list then gets sent to our Scheduler Extension , which is in charge of deciding which nodes can support the RDMA requirements specified in the pods yaml. The Scheduler Extension contacts each nodes RDMA Hardware Daemon Set , which returns a JSON formatted list of information about a nodes RDMA VF's back to the Scheduler Extension . The Scheduler Extension than processes all of the information to find a valid node that can meet the minimum bandwidth requirements of each of the requested interfaces that is specified in the pods yaml; the list of nodes whether blank or empty is sent back to the Kubernetes Core Scheduler. If no node is valid after the scheduling calls an error is raised and the pod is not placed, this error can be seen with a Kubernetes describe command of why the pod was not placed. Assuming that the pod was able to placed on at least one valid node, the Kubelet process on the valid node gets called to setup the pod. During the pods setup process the (CNI)[components.md#cni] is called to setup the network of the pod. The (CNI)[components.md#cni] first contacts the RDMA Hardware Daemon Set on the node that is running to get an up to date list of the state of the node. It then runs the same algorithm that the Scheduler Extension had run to find the correct placements of interfaces to meet the requirements of the bandwidth limitations. The (CNI)[components.md#cni] is atomic operation, so it either completes the setup of the pod or fails and rollbacks all changes made to any interfaces. Once the (CNI)[components.md#cni] finishes, the response is sent back to the Kubelet process of the node.","title":"Architecture"},{"location":"introduction/#limitations","text":"There are a couple limitations when it comes to our solution: - Mellanox Vendor - the following has only been test on a Mellanox Card - Data Plane Development Kit (DPDK) - the Mellanox solution may work with DPDK, it has not been tested with our solution (changes to (CNI)[https://github.com/rit-k8s-rdma/rit-k8s-rdma-sriov-cni] required) - Shared RDMA Device - the Mellanox solution may work with a shared RDMA interface, it has not been tested with our solution (changes to (CNI)[https://github.com/rit-k8s-rdma/rit-k8s-rdma-sriov-cni] required) - Dummy Device Plugin - the current solution requires the use of Device Plugin to give access to /dev/infiniband for open issues in Kubernets that can be found here and here . The main problem is Kubernetes does not have the ideas of a device directory that Docker has --device .","title":"Limitations"},{"location":"introduction/#future_work","text":"More Vendors - making the solution more interface driven so it can be adapted to more vendors then just Mellanox. Migrating CNI - the CNI is currently at an older version and we had to bootstrap the newer one, it should be upgraded. Scheduling - opening up the scheduler to be more adaptable to customizable scheduling algorithms.","title":"Future Work"},{"location":"introduction/#our_approach_in_short","text":"Problems Addressed: - VF's are specified per container - Network plugin only ever gives one vf per pod, this means that the device plugin which tracks the amount of available VF's does not maintain an accurate count of VF's being used - The VF's selected by Kuberentes to be allocated, may not match those actually allocated by the network plugin Solution: - Device Plugin (RDMA) - Changes to a DameonSet - Stores the current state of the nodes VF resources - Can be quierried through an API - Schedular extender - Queries each DameonSet on each node and then filters the possible nodes that a pod can be deployed on based on resource requirements in the annotations for the pod - Network Plugin (SRIOV) - Modify it to handle read pods meta-data - Read the amount of VF's - Read the bandwidth limitation on each VF - Modify plugin to set the bandwidth limits from read metadata - Add ability to set min_tx_rate and max_tx_rate","title":"Our Approach in Short"}]}